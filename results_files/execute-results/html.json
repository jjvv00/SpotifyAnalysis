{
  "hash": "bc74e4511b876741449690094449a75a",
  "result": {
    "markdown": "# Results\n\n## Average energy, valence, danceability % comparisons between our top artists\n\nGet all required libraries:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spotifyr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(knitr)\nlibrary(ggplot2)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ lubridate 1.9.3     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.0\n✔ readr     2.1.4     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(forcats)\nlibrary(ggridges)\nlibrary(tidyr)\nlibrary(broom)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'broom'\n\nThe following object is masked from 'package:spotifyr':\n\n    tidy\n```\n:::\n:::\n\n\nIn order to access Spotify's data, you must set up a Spotify Dev account. Once you do, you will get a client ID and client secret:\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(SPOTIFY_CLIENT_ID = \"d895b3472cb743c581bc155bd97d3c4e\", SPOTIFY_CLIENT_SECRET = \"348918affcf741d8841b9445b693c0d4\")\ntoken <- get_spotify_access_token()\n```\n:::\n\n\nCreate a dataframe for each artist's song collection using the spotifyr package's \"get_artist_audio_features\". This function produces dataframes with all of each artist's songs and multiple features about each song. We will only be using the \"artist_name\", \"album_release_date\", \"danceability\", \"valence\", \"energy\", \"track_name\", \"album_name\" features so we will remove the rest of them at this point. Then, we can download these dataframes as .csv files. \n\n::: {.cell}\n\n```{.r .cell-code}\nTS <- get_artist_audio_features('taylor swift')\nFM <- get_artist_audio_features('fleetwood mac')\nDC <- get_artist_audio_features('doja cat')\nPP <- get_artist_audio_features('peso pluma')\n\ndesktop_path <- file.path(Sys.getenv(\"HOME\"), \"Desktop\")\n\n# Save the data frames as CSV files\nTS <- subset(TS, select = c(\"artist_name\", \"album_release_date\", \"danceability\", \"valence\", \"energy\", \"track_name\", \"album_name\"))\nFM <- subset(FM, select = c(\"artist_name\", \"album_release_date\", \"danceability\", \"valence\", \"energy\", \"track_name\", \"album_name\"))\nDC <- subset(DC, select = c(\"artist_name\", \"album_release_date\", \"danceability\", \"valence\", \"energy\", \"track_name\", \"album_name\"))\nPP <- subset(PP, select = c(\"artist_name\", \"album_release_date\", \"danceability\", \"valence\", \"energy\", \"track_name\", \"album_name\"))\n\n\nwrite.csv(TS, file.path(desktop_path, \"TS.csv\"))\nwrite.csv(FM, file.path(desktop_path, \"FM.csv\"))\nwrite.csv(DC, file.path(desktop_path, \"DC.csv\"))\nwrite.csv(PP, file.path(desktop_path, \"PP.csv\"))\n\n# Display a message indicating the successful save\ncat(\"Data frames have been saved to:\", desktop_path, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData frames have been saved to: /Users/Ellise/Desktop \n```\n:::\n:::\n\n\nFirst, find the average energy across all of the songs for each artist separately. Then create a new dataframe with all four of these energy averages. We will display this data using a bar graph.\n\n::: {.cell}\n\n```{.r .cell-code}\nTSenergy_avg <- mean(TS$energy) #2274A5\nFMenergy_avg <- mean(FM$energy) #F75C03\nDCenergy_avg <- mean(DC$energy) #D90368\nPPenergy_avg <- mean(PP$energy) #F1C40F\n\nenergy_sums = c(TSenergy_avg, FMenergy_avg, DCenergy_avg, PPenergy_avg)\nlabels = c(\"Taylor Swift\", \"Fleetwood Mac\", \"Doja Cat\", \"Peso Pluma\")\n\nenergy_data = data.frame(Label = labels, Value = energy_sums)\n\nartist_colors <- c(\"Taylor Swift\" = \"#2274A5\", \n                    \"Fleetwood Mac\" = \"#F75C03\", \n                    \"Doja Cat\" = \"#D90368\", \n                    \"Peso Pluma\" = \"#F1C40F\")\n\n\nggplot(energy_data, aes(x = fct_rev(fct_reorder(Label, Value)), y = Value, fill = Label)) + \n  geom_bar(stat = \"identity\", color = \"black\") +\n  scale_x_discrete(name = \"Artist\") + \n  scale_y_continuous(name = \"Average energy of songs (%)\", breaks = seq(0, 1, by = 0.1)) + \n  labs(title = expression(\"Comparison of the\" ~ bold(\"Energy\") ~ \"of Songs from Our Top Artists\")) +\n  scale_fill_manual(values = artist_colors) + \n  theme(\n    axis.title.y = element_text(margin = margin(r = 15)),  \n    axis.title.x = element_text(margin = margin(t = 12))\n  )\n```\n\n::: {.cell-output-display}\n![](results_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nRepeat this process for the valence and danceability: \n\n::: {.cell}\n\n```{.r .cell-code}\nTSvalence_avg <- mean(TS$valence) \nFMvalence_avg <- mean(FM$valence) \nDCvalence_avg <- mean(DC$valence)\nPPvalence_avg <- mean(PP$valence)\n\nvalence_sums = c(TSvalence_avg, FMvalence_avg, DCvalence_avg, PPvalence_avg)\nlabels = c(\"Taylor Swift\", \"Fleetwood Mac\", \"Doja Cat\", \"Peso Pluma\")\n\nvalence_data = data.frame(Label = labels, Value = valence_sums)\n\nartist_colors <- c(\"Taylor Swift\" = \"#2274A5\", \n                    \"Fleetwood Mac\" = \"#F75C03\", \n                    \"Doja Cat\" = \"#D90368\", \n                    \"Peso Pluma\" = \"#F1C40F\")\n\nggplot(valence_data, aes(x = fct_rev(fct_reorder(Label, Value)), y = Value, fill = Label)) + \n  geom_bar(stat = \"identity\", color = \"black\") +\n  scale_x_discrete(name = \"Artist\") + \n  scale_y_continuous(name = \"Average valence of songs (%)\", breaks = seq(0, 1, by = 0.1))+ \n  labs(title = expression(\"Comparison of the\" ~ bold(\"Valence\") ~ \"of Songs from Our Top Artists\")) +\n  scale_fill_manual(values = artist_colors) + \n  theme(\n    axis.title.y = element_text(margin = margin(r = 15)),  \n    axis.title.x = element_text(margin = margin(t = 12))\n  )\n```\n\n::: {.cell-output-display}\n![](results_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nTSdanceability_avg <- mean(TS$danceability) \nFMdanceability_avg <- mean(FM$danceability) \nDCdanceability_avg <- mean(DC$danceability) \nPPdanceability_avg <- mean(PP$danceability) \n\ndanceability_sums = c(TSdanceability_avg, FMdanceability_avg, DCdanceability_avg, PPdanceability_avg)\nlabels = c(\"Taylor Swift\", \"Fleetwood Mac\", \"Doja Cat\", \"Peso Pluma\")\n\ndanceability_data = data.frame(Label = labels, Value = danceability_sums)\n\nartist_colors <- c(\"Taylor Swift\" = \"#2274A5\", \n                    \"Fleetwood Mac\" = \"#F75C03\", \n                    \"Doja Cat\" = \"#D90368\", \n                    \"Peso Pluma\" = \"#F1C40F\")\n\nggplot(danceability_data, aes(x = fct_rev(fct_reorder(Label, Value)), y = Value, fill = Label)) + \n  geom_bar(stat = \"identity\", color = \"black\") +\n  scale_x_discrete(name = \"Artist\") + \n  scale_y_continuous(name = \"Average danceability of songs (%)\", breaks = seq(0, 1, by = 0.1)) + \n  labs(title = expression(\"Comparison of the\" ~ bold(\"Danceability\") ~ \"of Songs from Our Top Artists\")) +\n  scale_fill_manual(values = artist_colors) + \n  theme(\n    axis.title.y = element_text(margin = margin(r = 15)),  \n    axis.title.x = element_text(margin = margin(t = 12))\n  )\n```\n\n::: {.cell-output-display}\n![](results_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nNow we will compare the moods of each artist based on the moods of each of their songs. This is based on James Russell's circumplex model as referenced in \"Feel the Moosic: Emotion-based Music Selection and Recommendation\" by Patrick Helmholz, Michael Meyer, Susanne Robra-Bissantz. In this paper, they classify songs into one of four different mood categories (happy, angry, sad, or relaxed) based on their energy and valence scores. We will use this model to display the most frequent song moods for each of our top artists. This should help us compare the moods of our music preferences. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Mutate data: add an extra column \"quadrant\" to hold the mood of the song based on its energy/valence\nTS <- TS %>%\n  mutate(\n    quadrant = case_when(\n      valence >= 0.5 & energy >= 0.5 ~ \"Happy\",\n      valence < 0.5 & energy >= 0.5 ~ \"Angry\",\n      valence < 0.5 & energy < 0.5 ~ \"Sad\",\n      TRUE ~ \"Relaxed\"\n    )\n  )\n\nquadrant_colors <- c(\n  \"Happy\" = \"green3\",\n  \"Angry\" = \"#FA0000CF\",\n  \"Sad\" = \"#8D6A9F\",\n  \"Relaxed\" = \"#63D2FF\"\n)\n\nggplot(TS, aes(x = valence, y = energy, color = quadrant)) +\n  geom_point(size = 1) +\n  xlim(0, 1) + ylim(0, 1) +  \n  geom_vline(xintercept = 0.5, linetype = \"dashed\") +  \n  geom_hline(yintercept = 0.5, linetype = \"dashed\") +\n  labs(\n    title = \"Scatter Plot of Valence vs. Energy in Taylor Swift's songs\", subtitle = \"Each quartile represents a different mood\",\n    x = \"Valence\",\n    y = \"Energy\",\n    color = \"Artist\") +\n  scale_color_manual(values = quadrant_colors) +\n  theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](results_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n#Citations: \n\n(paper and image)\nHelmholz, P., Meyer, M., & Robra-Bissantz, S. (2019, June 12). Feel the Moosic: Emotion-based Music Selection and Recommendation. https://doi.org/10.18690/978-961-286-280-0.11 \n\n\n",
    "supporting": [
      "results_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}